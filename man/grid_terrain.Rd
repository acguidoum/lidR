% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grid_terrain.r
\name{grid_terrain}
\alias{grid_terrain}
\alias{grid_terrain_delaunay}
\alias{grid_terrain_knnidw}
\alias{grid_terrain_kriging}
\title{Digital Terrain Model}
\usage{
grid_terrain(las, method, ...)

grid_terrain_delaunay(las, res = 1, keep_lowest = FALSE)

grid_terrain_knnidw(las, res = 1, k = 10L, p = 2, keep_lowest = FALSE)

grid_terrain_kriging(las, res = 1, k = 10L, model = gstat::vgm(0.59,
  "Sph", 874), keep_lowest = FALSE)
}
\arguments{
\item{las}{An object of class \link[lidR:LAS-class]{LAS} or \link[lidR:LAScatalog-class]{LAScatalog}.}

\item{method}{character. can be \code{"knnidw"}, \code{"delaunay"} or \code{"kriging"} (see details)}

\item{...}{parameters for the algorithms. These depend on the algorithm used (see documentation
of each method).}

\item{res}{numeric. resolution of the \code{RasterLayer}. Default 1.}

\item{keep_lowest}{logical. This option forces the original lowest ground point of each
cell (if it exists) to be chosen instead of the interpolated values.}

\item{k}{numeric. number of k-nearest neighbours. Default 10.}

\item{p}{numeric. Power for inverse-distance weighting. Default 2.}

\item{model}{a variogram model computed with \link[gstat:vgm]{vgm}. If null, it performs an ordinary
or weighted least squares prediction.}
}
\value{
A \code{RasterLayer} containing the metric for each cell.
}
\description{
Interpolates ground points and creates a rasterized digital terrain model. The interpolation
can be done using 3 methods: \code{"knnidw"}, \code{"delaunay"} or \code{"kriging"} (see
details). The algorithm uses the points classified as "ground" to compute the interpolation.\cr
Depending on the interpolation method, the edges of the dataset can be more, or less poorly
interpolated. A buffer around the region of interest is always recommended to avoid edge
effects.
}
\details{
\describe{
\item{\code{knnidw}}{Interpolation is done using a k-nearest neighbour (KNN) approach with
an inverse-distance weighting (IDW). This is a fast but basic method for spatial
data interpolation.}
\item{\code{delaunay}}{Interpolation based on Delaunay triangulation. It makes a linear
interpolation within each triangle. There are usually few cells outside the convex hull,
determined by the ground points at the very edge of the dataset that cannot be interpolated
with a triangulation. Extrapolation is done using knnidw.}
\item{\code{kriging}}{Interpolation is done by universal kriging using the
\link[gstat:krige]{krige} function. This method combines the KNN approach with the kriging
approach. For each point of interest the terrain is kriged using the k-nearest neighbour ground
points. This method is more difficult to manipulate but it is also the most advanced method for
interpolating spatial data. }
}
}
\section{Working with a \code{LAScatalog}}{

In \code{lidR} when the input of a function is a \link[lidR:LAScatalog-class]{LAScatalog} the
functions uses the internal catalog processing engine. The user can modify the engine options using
the \link[lidR:catalog_options_tools]{available options}. A careful read of the engine
\link[lidR:LAScatalog-class]{engine documentation} is recommended to process \code{LAScatalogs}. Each
function should come with a section that doucment the avaible engine options.\cr\cr
\code{LAScatalog} engine supports \code{.lax} files that \strong{significantly} improve the computation
speed of spatial queries using a spatial index. Users should really take advange a \code{.lax} files
but this is not mandatory.
}

\section{Supported processing options}{

Supported processing options for a \code{LAScatalog} in \code{grid_*} functions (in bold). For
more details see the \link[lidR:LAScatalog-class]{LAScatalog engine documentation}:
\itemize{
\item \strong{tiling_size}: How much data are loaded at once. The tiling size may be slightly modified
internally to ensure a strict wall-to-wall continuous output even when tiling size equal to 0 (processing
by file).
\item buffer: This function guarantee a stric wall-to-wall continuous output. The \code{buffer} option
is no considered.
\item \strong{alignment}: Align the processed clusters. The alignment may be slightly modified
internally to ensure a strict wall-to-wall continuous output.
\item \strong{cores}: How many cores are used.
\item \strong{progress}: Displays a progression estimation.
\item \strong{stop_early}: Leave it as it unless you are an advanced user.
\item \strong{output_files}: Return the output in R or write each cluster's output in a file. Supported
templates are \code{XLEFT}, \code{XRIGHT}, \code{YBOTTOM}, \code{YTOP}, \code{XCENTER}, \code{YCENTER}
\code{ID} and, if tiling size equal to 0 (processing by file), \code{ORIGINALFILENAME}.
\item laz_compression: is not supported because this function will never write \code{las/laz} files
\item \strong{drivers}: Leave it as it unless you are an advanced user.
\item \strong{\emph{select}}: The functions \code{grid_*} usually know for you what should be loaded or not
and this options is not considered. In \link{grid_metrics} this option is respected.
\item \strong{filter}: Read only points of interest.
}
}

\examples{
LASfile <- system.file("extdata", "Topography.laz", package="lidR")
las = readLAS(LASfile)
plot(las)

dtm1 = grid_terrain(las, method = "knnidw", k = 6L, p = 2)
dtm2 = grid_terrain(las, method = "delaunay")
dtm3 = grid_terrain(las, method = "kriging", k = 10L)

\dontrun{
plot(dtm1)
plot(dtm2)
plot(dtm3)
plot3d(dtm1)
plot3d(dtm2)
plot3d(dtm3)
}
}
\seealso{
\link{lasnormalize}
}
