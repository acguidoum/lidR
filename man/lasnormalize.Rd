% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lasnormalize.r
\docType{methods}
\name{lasnormalize}
\alias{lasnormalize}
\alias{lasnormalize_dtm}
\alias{lasnormalize_tin}
\alias{lasnormalize_knnidw}
\alias{lasnormalize_kriging}
\alias{lasunnormalize}
\alias{-,LAS,RasterLayer-method}
\title{Remove the topography from a point cloud}
\usage{
lasnormalize(las, method, ...)

lasnormalize_dtm(las, dtm)

lasnormalize_tin(las)

lasnormalize_knnidw(las, k = 10L, p = 1)

lasnormalize_kriging(las, k = 10L, model = gstat::vgm(0.59, "Sph", 874))

lasunnormalize(las)

\S4method{-}{LAS,RasterLayer}(e1, e2)
}
\arguments{
\item{las}{An object of class \code{LAS} or \code{LAScatalog}.}

\item{method}{character. Can be \code{"dtm"}, \code{"knnidw"}, \code{"tin"} or \code{"kriging"}
(see details)}

\item{dtm}{a \link[raster:raster]{RasterLayer} representing a digital terrain model (can be
computed with \link{grid_terrain}).}

\item{k}{numeric. Number of k-nearest neighbours. Default 10.}

\item{p}{numeric. Power for inverse distance weighting. Default 2.}

\item{model}{A variogram model computed with \link[gstat:vgm]{vgm}. If NULL it performs an ordinary
or weighted least squares prediction.}

\item{e1}{a LAS object}

\item{e2}{a RasterLayer}
}
\value{
If the input is a \code{LAS} object the function returns NULL. The LAS object is updated
by reference. Z is now the normalized elevation, A new column 'Zref' records the former elevation
values which enable to use \code{lasunormalize} to restore original point elevations.\cr
If the input is a \code{LAScatalog} object, a new \code{LAScatalog}.
}
\description{
Subtract digital terrain model (DTM) from LiDAR point cloud to create a dataset normalized with
the ground at 0. The DTM can originate from an external file or be computed by the user. It can
also be computed on the fly. In this case the algorithm does not use rasterized data and each point
is interpolated. There is no inaccuracy due to the discretization of the terrain and the resolution
of the terrain is virtually infinite (but it is slower).\cr
Depending on the interpolation method, the edges of the dataset can be more, or less poorly
interpolated. A buffer around the region of interest is always recommended to avoid edge
effects.

Convenient operator to lasnormalize
}
\details{
\describe{
\item{\code{dtm}}{Normalization is done by substracting the digital terrain model to the point cloud.
The \code{RasterLayer} must encompass the whole point cloud. If a single point fall within a NA pixel
the methods will stop and throw an error.}
\item{\code{knnidw}}{Normalization is done by without rasterizationby interpolating each point.
Spatial interpolation is done using a k-nearest neighbour (KNN) approach with an inverse distance
weighting (IDW). This is a fast but basic method for spatial data interpolation.}
\item{\code{tin}}{Normalization is done by without rasterization by interpolating each point.
Spatial interpolation is based on a Delaunay triangulation. It performs a linear
interpolation within each triangle. There are usually a few points outside the convex hull,
determined by the ground points at the very edge of the dataset, which cannot be interpolated
with a triangulation. Extrapolation is done using knnidw.}
\item{\code{kriging}}{Normalization is done by without rasterizationby interpolating each point.
Spatial interpolation is done by universal kriging using the \link[gstat:krige]{krige} function.
This method combines the KNN approach with the kriging approach. For each point of interest it
kriges the terrain using the k-nearest neighbour ground points. This method is more difficult to
manipulate but it is also the most advanced method for interpolating spatial data. }
}

\code{lasunnormalize} enables restoration of the original elevation in a memory efficient way
in the case when the original elevations are recorded in the columns \code{Zref} (i.e. if
the point cloud was normalized with the package lidR).
}
\section{Working with a \code{LAScatalog}}{

In \code{lidR} when the input is a \link[lidR:LAScatalog-class]{LAScatalog} the functions run following
the catalog processing options. The user can modify the processing options using the
\link[lidR:catalog]{available options}.\cr\cr
\code{lidR} supports .lax files that \strong{significantly} improve the computation speed of
spatial queries using a spatial index. Users should really take advange a .lax files but this is
not mandatory.
}

\section{Supported processing options for a LAScatalog}{

\itemize{
\item \strong{cores}: See \link{LAScatalog-class}.
\item \strong{progress}: See \link{LAScatalog-class}.
\item \strong{stop_early}: See \link{LAScatalog-class}.
\item \strong{by_file}: See \link{LAScatalog-class}.
\item \strong{tiling_size}: See \link{LAScatalog-class}.
\item \strong{alignment}: See \link{LAScatalog-class}.
\item \strong{output_files*}: Requiered because the output is likely to be too big to be returned
 in R and needs to be written in las/laz files.
}
}

\examples{
LASfile <- system.file("extdata", "Topography.laz", package="lidR")
las = readLAS(LASfile)

plot(las)

# First option: compute a raster DTM with grid_terrain (or read it from a file)
# ============================================================================

dtm = grid_terrain(las, method = "kriging", k = 10L)
lasnormalize(las, method = "dtm", dtm = dtm)

plot(dtm)
plot(las)

# restore original elevations
lasunnormalize(las)
plot(las)

# operator - can be used. This is equivalent to the previous line
las - dtm
plot(las)

# restore original elevations
lasunnormalize(las)

# Second option: interpolate each point (no discretization)
# =========================================================

lasnormalize(las, method = "kriging", k = 10L, model = gstat::vgm(0.59, "Sph", 874))
plot(las)
}
\seealso{
\link[raster:raster]{raster}
\link[lidR:grid_terrain]{grid_terrain}
}
