% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lasfilterdecimate.r
\name{lasfilterdecimate}
\alias{lasfilterdecimate}
\title{Thin LiDAR data}
\usage{
lasfilterdecimate(las, density, homogenize = TRUE, res = 5,
  use_pulse = FALSE)
}
\arguments{
\item{las}{An object of class \link[lidR:LAS-class]{LAS} or \link[lidR:LAScatalog-class]{LAScatalog}.}

\item{density}{numeric. The expected density}

\item{homogenize}{logical. If \code{TRUE}, the algorithm tries to homogenize the pulse density to
provide a uniform dataset. If \code{FALSE} the algorithm will reach the pulse density over the whole
area.}

\item{res}{numeric. Cell size to compute the pulse density.}

\item{use_pulse}{logical. Decimate by removing random pulses instead of random points (requieres to run
\link{laspulse} first)}
}
\value{
If the input is a \code{LAS} object, returns a \code{LAS} object. If the input is a
\code{LAScatalog} returns a \code{LAScatalog}.
}
\description{
This routine creates a grid with a given resolution and filters the point cloud by selecting randomly
some point in each cell. It is designed to produce output datasets that have uniform densities throughout
the coverage area. For each cell, the proportion of points/pulses that will be retained is computed
using the actual density and the desired density. If the required density is greater than the actual
density it returns an unchanged set of points (it cannot increase the' density). If \code{homogenize = FALSE}
is selected, it randomly removes points/pulses to reach the required density over the whole area (see
\code{\link[lidR:area]{area}}). The cell size must be large enough to compute a coherent local pulse
density i.e., in a 2 points/m^2 dataset, 25 square meters would be feasible; however, an extent too
small to thin (e.g. <1 square meter) would not be feasible because density does not have meaning
at this scale.
}
\section{Supported processing options}{

Supported processing options for a \code{LAScatalog} (in bold). For more details see the
\link[lidR:LAScatalog-class]{LAScatalog engine documentation}:
\itemize{
\item \strong{tiling_size}: How many data are loaded at once.
\item buffer: This function guarantee a stric wall-to-wall continous output. The \code{buffer} option
is no considered.
\item \strong{alignment}: Align the processed clusters
\item \strong{cores}: How many cores are used.
\item \strong{progress}: Displays a progression estimation.
\item \strong{stop_early}: Leave it as it unless you are an advanced user.
\item \strong{output_files*}: Mandatory because the output is likely to be too big to be returned
in R and needs to be written in las/laz files. Supported templates are \code{XLEFT}, \code{XRIGHT},
\code{YBOTTOM}, \code{YTOP}, \code{XCENTER}, \code{YCENTER} \code{ID} and, if tiling size equal to 0
(processing by file), \code{ORIGINALFILENAME}.
\item \strong{laz_compression}: write \code{las} or \code{laz} files
\item \strong{drivers}: Leave it as it unless you are an advanced user.
\item select: The function will write file equivalent to the original ones. Thus \code{select = "*"}
and cannot be changed.
\item \strong{filter}: Read only points of interest.
}
}

\section{Working with a \code{LAScatalog}}{

In \code{lidR} when the input of a function is a \link[lidR:LAScatalog-class]{LAScatalog} the
functions uses the internal catalog processing engine. The user can modify the engine options using
the \link[lidR:catalog_options_tools]{available options}. A careful read of the engine
\link[lidR:LAScatalog-class]{engine documentation} is recommended to process \code{LAScatalogs}. Each
function should come with a section that doucment the avaible engine options.\cr\cr
\code{LAScatalog} engine supports \code{.lax} files that \strong{significantly} improve the computation
speed of spatial queries using a spatial index. Users should really take advange a \code{.lax} files
but this is not mandatory.
}

\examples{
LASfile <- system.file("extdata", "Megaplot.laz", package="lidR")
las = readLAS(LASfile, select = "xyz")

# By default the method is homogenize = TRUE
thinned = lasfilterdecimate(las, 1, res = 5)
plot(grid_density(las))
plot(grid_density(thinned))

# Method homogenize = FALSE enables a global pulse density to be reached
thinned = lasfilterdecimate(las, 1, homogenize = FALSE)
summary(thinned)
d = grid_density(thinned)
plot(d)
}
\seealso{
Other lasfilters: \code{\link{lasfiltersurfacepoints}},
  \code{\link{lasfilters}}, \code{\link{lasfilter}}
}
