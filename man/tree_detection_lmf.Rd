% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tree_detection.r
\name{tree_detection_lmf}
\alias{tree_detection_lmf}
\title{Tree top detection based local maxima filters}
\usage{
tree_detection_lmf(x, ws, hmin = 2, shape = c("circular", "square"), ...)
}
\arguments{
\item{x}{An object of class \code{LAS} or \code{LAScatalog} or a \code{RasterLayer} representing a
canopy height model.}

\item{ws}{numeric or function. Length or diameter of the moving window used to the detect the local
maxima in the unit of the input data (usually meters). If it is numeric a fixed windows size is used.
If it is a function, the function determines the size of the window at any given location on the canopy.
It should take the height of a given pixel or points as its only argument and return the desired size
of the search window when centered on that pixel/point.}

\item{hmin}{numeric. Minimum height of a tree. Threshold below which a pixel or a point
cannot be a local maxima. Default 2.}

\item{shape}{character. Shape of the moving windows used to find the local maxima. Can be "square"
or "circular".}

\item{...}{Additional argument for \link{readLAS} to reduce the amount of data loaded (only with a
\code{LAScatalog} object).  Actually \code{filter} is the sole authorized argument since \code{select = "xyz"}
is imposed internally.}
}
\value{
A \code{SpatialPointsDataFrame} with the 2D coordinates of the tree tops (X, Y) and the elevation of
the apex and the id of each tree in the table of attributes (attributes \code{Z} and \code{treeID} respectively)
}
\description{
Tree top detection based on local maxima filters. The windows size can be fix or variable and the
windows shape can be square or circular. The internal algorithm works either with a raster or a point
cloud
}
\section{Working with a \code{LAScatalog}}{

In \code{lidR} when the input of a function is a \link[lidR:LAScatalog-class]{LAScatalog} the
functions uses the internal catalog processing engine. The user can modify the engine options using
the \link[lidR:catalog_options_tools]{available options}. A careful read of the engine
\link[lidR:LAScatalog-class]{engine documentation} is recommended to process \code{LAScatalogs}. Each
function should come with a section that doucment the avaible engine options.\cr\cr
\code{LAScatalog} engine supports \code{.lax} files that \strong{significantly} improve the computation
speed of spatial queries using a spatial index. Users should really take advange a \code{.lax} files
but this is not mandatory.
}

\section{Supported processing options}{

Supported processing options for a \code{LAScatalog} (in bold). For more details see the
\link[lidR:LAScatalog-class]{LAScatalog engine documentation}:
\itemize{
\item \strong{tiling_size}: How many data are loaded at once.
\item \strong{buffer*}: Mandatory to get a continuous output without edge effect. The buffer is
always removed once processed and will never be returned neither in R nor in files.
\item \strong{alignment}: Align the processed clusters
\item \strong{cores}: How many cores are used. .
\item \strong{progress}: Displays a progression estimation.
\item \strong{stop_early}: Leave it as it unless you are an advanced user.
\item \strong{output_files*}: Requiered because the output is likely to be too big to be returned
 in R and needs to be written in las/laz files.
\item \strong{laz_compression}: write \code{las} or \code{laz} files
\item \strong{drivers}: Leave it as it unless you are an advanced user.
\item select: The function will write file equivalent to the original ones. Thus \code{select = "*"}
and cannot be changed.
\item \strong{filter}: Read only points of interest.
}
}

\examples{
LASfile <- system.file("extdata", "MixedConifer.laz", package="lidR")
las = readLAS(LASfile, select = "xyz", filter = "-drop_z_below 0")

# point-cloud-based
# =================

# 5x5 m fixed windows size
ttops = tree_detection_lmf(las, 5)

plot(las)
rgl::spheres3d(ttops@coords[,1], ttops@coords[,2], ttops@data$Z, col = "red", size = 5, add = TRUE)

# variable windows size
f = function(x) { x * 0.07 + 3}
ttops = tree_detection_lmf(las, f)

plot(las)
rgl::spheres3d(ttops@coords[,1], ttops@coords[,2], ttops@data$Z, col = "red", size = 5, add = TRUE)

# raster-based
# ============

# 5x5 m fixed windows size
chm = grid_canopy(las, "p2r", 1, subcircle = 0.15)
kernel = matrix(1,3,3)
chm = raster::focal(chm, w = kernel, fun = median, na.rm = TRUE)

ttops = tree_detection_lmf(chm, 5)

raster::plot(chm, col = height.colors(30))
sp::plot(ttops, add = TRUE)

# variable windows size
f = function(x) { x * 0.07 + 3 }
ttops = tree_detection_lmf(chm, f)

raster::plot(chm, col = height.colors(30))
sp::plot(ttops, add = TRUE)
}
